(function() {
  this.null = this.null || {};
  this.PercySDKUtils.TestHelpers = (function (require$$0, require$$2, require$$1$1, require$$2$1) {
  	'use strict';

  	const process = (typeof globalThis !== "undefined" && globalThis.process) || {};
  	process.env = process.env || {};
  	process.env.__PERCY_BROWSERIFIED__ = true;

  	globalThis.process = globalThis.process || process;

  	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  	var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
  	var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
  	var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
  	var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);

  	function getAugmentedNamespace(n) {
  		if (n.__esModule) return n;
  		var a = Object.defineProperty({}, '__esModule', {value: true});
  		Object.keys(n).forEach(function (k) {
  			var d = Object.getOwnPropertyDescriptor(n, k);
  			Object.defineProperty(a, k, d.get ? d : {
  				enumerable: true,
  				get: function () {
  					return n[k];
  				}
  			});
  		});
  		return a;
  	}

  	const {
  	  assign,
  	  entries
  	} = Object; // matches ansi escape sequences

  	const ANSI_REG$1 = new RegExp('[\\u001B\\u009B][[\\]()#;?]*((?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)' + '|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))', 'g'); // color names by ansi escape code

  	const ANSI_COLORS = {
  	  '31m': 'red',
  	  '33m': 'yellow',
  	  '34m': 'blue',
  	  '35m': 'magenta',
  	  '90m': 'grey'
  	}; // colorize each line of a string using an ansi escape sequence

  	const LINE_REG = /^.*$/gm;

  	function colorize(code, str) {
  	  return str.replace(LINE_REG, line => `\u001b[${code}${line}\u001b[39m`);
  	} // map ansi colors to bound colorize functions


  	const colors = entries(ANSI_COLORS).reduce((colors, [code, name]) => {
  	  return assign(colors, {
  	    [name]: colorize.bind(null, code)
  	  });
  	}, {});

  	var util = /*#__PURE__*/Object.freeze({
  		__proto__: null,
  		ANSI_REG: ANSI_REG$1,
  		ANSI_COLORS: ANSI_COLORS,
  		colors: colors
  	});

  	var require$$1 = /*@__PURE__*/getAugmentedNamespace(util);

  	const logger$1 = require$$0__default['default'];
  	const {
  	  ANSI_REG
  	} = require$$1;
  	const {
  	  Logger
  	} = logger$1;
  	const ELAPSED_REG = /\s\S*?\(\d+ms\)\S*/;
  	const NEWLINE_REG = /\r\n/g;
  	const LASTLINE_REG = /\n$/;

  	function sanitizeLog(str, {
  	  ansi,
  	  elapsed
  	} = {}) {
  	  // normalize line endings
  	  str = str.replace(NEWLINE_REG, '\n'); // strip ansi colors

  	  if (!ansi) str = str.replace(ANSI_REG, ''); // strip elapsed time

  	  if (!elapsed) str = str.replace(ELAPSED_REG, ''); // strip trailing line endings

  	  return str.replace(LASTLINE_REG, '');
  	}

  	function TestIO(data, options) {
  	  if (!process.env.__PERCY_BROWSERIFIED__) {
  	    let {
  	      Writable
  	    } = require$$2__default['default'];
  	    return Object.assign(new Writable(), {
  	      isTTY: options && options.isTTY,

  	      cursorTo() {},

  	      clearLine() {},

  	      _write(chunk, encoding, callback) {
  	        data.push(sanitizeLog(chunk.toString(), options));
  	        callback();
  	      }

  	    });
  	  }
  	}

  	function spy(object, method, func) {
  	  if (object[method].reset) {
  	    object[method].reset();
  	    return object[method];
  	  }

  	  let spy = Object.assign(function spy(...args) {
  	    spy.calls.push(args);
  	    if (func) return func.apply(this, args);
  	  }, {
  	    restore: () => object[method] = spy.originalValue,
  	    reset: () => spy.calls.length = 0,
  	    originalValue: object[method],
  	    calls: []
  	  });
  	  object[method] = spy;
  	  return spy;
  	}

  	const helpers$1 = {
  	  constructor: Logger,
  	  loglevel: logger$1.loglevel,
  	  stdout: [],
  	  stderr: [],

  	  get messages() {
  	    return Logger.instance && Logger.instance.messages;
  	  },

  	  mock(options) {
  	    helpers$1.reset();
  	    helpers$1.options = options;

  	    if (!process.env.__PERCY_BROWSERIFIED__) {
  	      Logger.stdout = TestIO(helpers$1.stdout, options);
  	      Logger.stderr = TestIO(helpers$1.stderr, options);
  	    } else {
  	      spy(Logger.prototype, 'write', function (lvl, msg) {
  	        let stdio = lvl === 'info' ? 'stdout' : 'stderr';
  	        helpers$1[stdio].push(sanitizeLog(msg, helpers$1.options));
  	        return this.write.originalValue.call(this, lvl, msg);
  	      });
  	      spy(console, 'log');
  	      spy(console, 'warn');
  	      spy(console, 'error');
  	    }
  	  },

  	  reset() {
  	    delete Logger.instance;
  	    helpers$1.stdout.length = 0;
  	    helpers$1.stderr.length = 0;

  	    if (console.log.reset) {
  	      console.log.reset();
  	      console.warn.reset();
  	      console.error.reset();
  	    }
  	  },

  	  dump() {
  	    if (!helpers$1.messages || !helpers$1.messages.size) return;
  	    if (console.log.and) console.log.and.callThrough();

  	    let write = m => process.env.__PERCY_BROWSERIFIED__ ? console.log(m) : process.stderr.write(`${m}\n`);

  	    let logs = Array.from(helpers$1.messages);
  	    logger$1.loglevel('debug');
  	    write(logger$1.format('--- DUMPING LOGS ---', 'testing', 'warn'));
  	    logs.reduce((lastlog, {
  	      debug,
  	      level,
  	      message,
  	      timestamp
  	    }) => {
  	      write(logger$1.format(message, debug, level, timestamp - lastlog));
  	      return timestamp;
  	    }, logs[0].timestamp);
  	  }

  	};
  	var helpers_1$1 = helpers$1;

  	const logger = helpers_1$1;
  	const utils = require$$1__default['default'];
  	const helpers = {
  	  logger,

  	  async setup() {
  	    utils.percy.version = '';
  	    delete utils.percy.config;
  	    delete utils.percy.enabled;
  	    delete utils.percy.domScript;
  	    delete process.env.PERCY_SERVER_ADDRESS;
  	    await helpers.call('server.mock');
  	    logger.mock();
  	  },

  	  teardown: () => helpers.call('server.close'),
  	  getRequests: () => helpers.call('server.requests'),
  	  testReply: (path, reply) => helpers.call('server.reply', path, reply),
  	  testFailure: (path, error) => helpers.call('server.test.failure', path, error),
  	  testError: path => helpers.call('server.test.error', path),
  	  testSerialize: fn => !fn ? helpers.call('server.test.serialize') // get
  	  : helpers.call('server.test.serialize', fn),
  	  // set
  	  mockSite: () => helpers.call('site.mock'),
  	  closeSite: () => helpers.call('site.close')
  	};

  	if (process.env.__PERCY_BROWSERIFIED__) {
  	  helpers.call = async function call(event, ...args) {
  	    let {
  	      socket,
  	      pending = {}
  	    } = helpers.call;

  	    if (!socket) {
  	      socket = new window.WebSocket('ws://localhost:5339');
  	      await new Promise((resolve, reject) => {
  	        let done = event => {
  	          clearTimeout(timeoutid);
  	          socket.onopen = socket.onerror = null;

  	          if (event && (event.error || event.type === 'error')) {
  	            reject(event.error || new Error('Test client connection failed'));
  	          } else resolve(socket);
  	        };

  	        let timeoutid = setTimeout(done, 1000, {
  	          error: new Error('Test client connection timed out')
  	        });
  	        socket.onopen = socket.onerror = done;
  	      });

  	      socket.onmessage = ({
  	        data
  	      }) => {
  	        let {
  	          id,
  	          resolve,
  	          reject
  	        } = JSON.parse(data);
  	        if (!pending[id]) return;
  	        if (resolve) pending[id].resolve(resolve.result);
  	        if (reject) pending[id].reject(reject.error);
  	      };

  	      Object.assign(helpers.call, {
  	        socket,
  	        pending
  	      });
  	    }

  	    let id = helpers.call.uid = (helpers.call.uid || 0) + 1;
  	    args = args.map(a => typeof a === 'function' ? a.toString() : a);
  	    socket.send(JSON.stringify({
  	      id,
  	      event,
  	      args
  	    }));
  	    return (pending[id] = {}).promise = new Promise((resolve, reject) => {
  	      Object.assign(pending[id], {
  	        resolve,
  	        reject
  	      });
  	    });
  	  };
  	} else {
  	  helpers.context = require$$2__default$1['default'].context();
  	  helpers.call = helpers.context.call;
  	}

  	var helpers_1 = helpers;

  	return helpers_1;

  }(PercySDKUtils.logger, null, PercySDKUtils, null));
}).call(window);

if (typeof define === "function" && define.amd) {
  define([], () => window.PercySDKUtils.TestHelpers);
} else if (typeof module === "object" && module.exports) {
  module.exports = window.PercySDKUtils.TestHelpers;
}
